#ifdef _WINDOWS
// #include <GL/glew.h>
#endif
#include <SDL.h>
#define GL_GLEXT_PROTOTYPES 1
#include <SDL_opengl.h>

#include <SDL_mixer.h>

#include "glm/mat4x4.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "ShaderProgram.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#ifdef _WINDOWS
#define RESOURCE_FOLDER ""
#else
#define RESOURCE_FOLDER "NYUCodebase.app/Contents/Resources/"
#endif

#include <vector>
#include <algorithm>
#include <unistd.h>

#define MAX_BULLETS 16
#define MAX_ENEMIES 12

#define FIXED_TIMESTEP 0.0166666f
#define MAX_TIMESTEPS 6

#define LEVEL_HEIGHT 96
#define LEVEL_WIDTH 34

#define SPRITE_COUNT_X 16
#define SPRITE_COUNT_Y 8
#define TILE_SIZE 1.0f/12.0f

#define WORLD_SHIFT_X -1.8f

#define NUM_SOLIDS 6

#define TINY_VALUE 0.03125f

// Generic print function for debugging found at: https://stackoverflow.com/a/22483243
template <typename T>
void print_container(const T&);

template <typename T>
void print(const std::vector<T>& v) { print_container(v); }

template <typename T>
void print(const T& e) { std::cout << e << std::endl; }

template <typename T>
void print_container(const T& c) {
    std::cout << "[";
    bool isFirst = true;
    for (const auto& e : c) {
        if (isFirst) isFirst = false;
        else std::cout << ",";
        print(e);
    }
    std::cout << "]" << std::endl;
}

// Global Data

enum GameMode {
    MAIN_MENU,
    GAME_LEVEL,
    CONTINUE,
    GAME_OVER,
};

enum GameLevel {
    ONE,
    TWO,
    THREE,
};

GameMode gameMode = MAIN_MENU;
GameLevel gameLevel = ONE;

unsigned int levelOne[LEVEL_HEIGHT][LEVEL_WIDTH] =
{
    {49,10,10,10,10, 10,10,10,10,10, 10,10,10,10,10, 12,13,14, 15,10,10,10,10, 10,10,10,10,10, 10,10,10,10,49},
    {49,0,0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 2,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,2, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,2, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,2, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,2, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,2, 49,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 2,0,0,0,0, 2,2,2,49,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,2,2,49},
    {49,0,0,0,2, 49,2,0,0,0, 0,0,2,49,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,2,49, 0,49,2,2,0, 0,0,2,49,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,2,49,0, 0,0,49,49,2, 0,0,2,49,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,2,49,0,0, 0,0,0,0,49, 2,2,49,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,0,0,0, 0,0,0,0,0, 49,49,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,2, 2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,49,2,2,2, 2,2,2,2,2, 2,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,2,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,2,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,49},
    {49,2,2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,49},

    {49,49,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,2,2, 2,0,0,0,2, 2,2,2,0,49},
    {49,0,49,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,2,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,49, 49,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,49, 2,0,0,0,2, 0,0,0,0,49},

    {49,0,0,0,0, 0,49,0,0,0, 49,0,0,0,0, 0,0,0, 0,0,0,49,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,49,0,49, 0,49,49,0,0, 0,0,0, 0,0,49,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,49,0, 0,0,0,49,49, 0,49,0, 0,49,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,0,49, 49,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,2,2, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,2,49,49, 2,0,0,0,2, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,2,49,0,0, 2,0,0,0,2, 0,0,0,0,49},

    {49,0,0,0,0, 0,2,0,0,0, 0,2,2,2,0, 0,0,0, 2,49,0,0,0, 2,0,0,0,2, 2,0,0,0,49},
    {49,0,0,0,2, 2,49,2,0,0, 2,49,49,49,2, 0,0,0, 2,49,0,0,0, 0,0,0,0,0, 49,2,0,0,49},
    {49,0,0,2,49, 49,0,49,2,2, 49,0,0,0,49, 2,2,2, 49,0,0,0,0, 0,0,0,0,0, 0,49,2,2,49},
    {49,0,2,49,0, 0,0,0,49,49, 0,0,0,0,0, 49,49,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,49,49,49},

    {49,2,49,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 2,2,2,2,2, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,2,2,2, 2,0,0,0,0, 2,2,2, 2,2,2,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,2,2,0, 0,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,2,2,2,49},
    {49,0,2,0,0, 0,0,0,49,2, 0,0,2,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,2,2, 0,0,0,0,49},
    {49,0,49,0,0, 0,0,0,0,49, 2,2,2,0,0, 0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,2,0, 0,0,0, 0,0,0,0,0, 0,2,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,2, 2,2,2, 2,2,2,2,2, 2,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,2,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,49,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,2,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 2,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,2,2,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,2,2, 2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,49,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,2,2, 2,0,0,2,2, 0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,2,0,0, 2,0,0,2,2, 0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,2,0,0,0, 2,2,2,0,2, 0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,2,0,0, 0,0,0,0,2, 0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,49,0,49, 0,49,2,0,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,0,49,0, 49,0,2,0,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,2,0,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,2,0,0, 0,0,0,2,0, 0,2,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,0, 0,0,2,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,0, 0,0,2,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,2,0,0,0, 0,0,0, 0,0,0,2,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,2,0,0,0, 0,0,0, 0,0,0,2,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2,2,49}
};

unsigned int levelTwo[LEVEL_HEIGHT][LEVEL_WIDTH] =
{
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,10,10,10,10, 10,10,10,10,10, 10,10,10,10,10, 12,13,14,15,10, 10,10,10,10,10, 10,10,10,10,10, 10,10,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,49,49,0,2, 49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,49,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,49,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,49,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,49,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 49,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,0,0,2, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,2,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,2,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,2, 0,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49, 49,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,2,0, 0,0,0,0,0, 0,0,0,0,0, 2,0,0,0,0, 0,0,0,2,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,2,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 2,2,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,49},
    
    {49,0,0,0,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,2,2, 2,2,2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,2,2,2,2, 2,2,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,2,2,2,2, 2,2,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,2,2, 2,2,2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},

    {49,2,2,2,2, 2,2,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,2,2,2,2, 2,2,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,2,2, 2,2,2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,2,2,2,2, 2,2,2,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,2,2,2,2, 2,2,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,2,2,2, 2,2,2,2,2, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49},
    {49,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,49}
};

unsigned int levelThree[LEVEL_HEIGHT][LEVEL_WIDTH] =
{
    {49,10,10,10,10, 10,10,10,10,10, 10,10,10,10,12, 13,14,15, 10,10,10,10,10, 10,10,10,10,10, 10,10,10,10,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,49,49,49, 49,49,49,49,49, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 49,49,49,49,49, 49,49,49,49,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,2,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0,0,49},
    {49,49,0,0,0, 0,0,49,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,49,0,0, 0,0,0,49,49},
    {49,0,49,0,0, 0,0,49,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,49,0,0, 0,0,49,0,49},

    {49,0,0,49,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,49,0, 0,49,0,0,49},
    {49,0,0,0,49, 49,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,49, 49,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,49,0, 0,0,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,49,0,0, 0,0,0, 0,0,49,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,49,0,2, 2,2,2, 2,0,49,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,49,0, 0,49,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49, 0,0,0, 49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,2,0, 0,0,0,2,0, 0,0,0,2,0, 49,49,49, 0,2,0,0,0, 0,2,0,0,0, 0,2,0,0,49},

    {49,0,0,49,0, 0,0,0,49,0, 0,0,0,49,0, 0,49,0, 0,49,0,0,0, 0,49,0,0,0, 0,49,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,2,0,0,0, 0,2,0,0,0, 0,2,0,0,0, 0,2,0, 0,0,0,2,0, 0,0,0,2,0, 0,0,0,2,49},

    {49,49,0,0,0, 0,49,0,0,0, 0,49,0,0,0, 0,49,0, 0,0,0,49,0, 0,0,0,49,0, 0,0,0,49,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,2,0, 0,0,0,2,0, 0,0,0,2,0, 49,49,49, 0,2,0,0,0, 0,2,0,0,0, 0,2,0,0,49},

    {49,0,0,49,0, 0,0,0,49,0, 0,0,0,49,0, 0,49,0, 0,49,0,0,0, 0,49,0,0,0, 0,49,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,49,2,2, 2,49,0,0,0, 0,0,0, 0,0,0,49,2, 2,2,49,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,49,2, 49,0,0,0,0, 0,0,0, 0,0,0,0,49, 2,49,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,49,49,49, 49,49,49,49,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,49,49,49,49, 49,49,49,49,49},
    {49,0,0,0,0, 0,0,0,0,49, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 49,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,49,49, 0,0,0,0,49, 2,2,2, 49,0,0,0,0, 49,49,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,49,0,0, 0,0,0,0,0, 49,49,49, 0,0,0,0,0, 0,0,49,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,49,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,49,0, 0,0,0,0,49},
    {49,0,0,0,0, 49,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,49, 0,0,0,0,49},

    {49,0,0,49,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,49,0,0,49},
    {49,0,49,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49,0,49},
    {49,49,0,0,0, 0,0,0,0,2, 2,0,0,0,0, 0,0,0, 0,0,0,0,2, 2,0,0,0,0, 0,0,0,49,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,49,0,0,0, 0,0,0, 0,0,0,49,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,49,2,0, 0,0,0, 0,2,49,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,2, 2,49,49,49,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,49,49,49,2, 2,0,0,0,49},

    {49,0,0,0,49, 49,0,0,0,49, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 49,0,0,0,49, 49,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 49,49,0,2,0, 0,0,0, 0,2,0,49,49, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,49,2,0, 0,0,0, 0,2,49,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,2,0, 0,0,0, 0,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,2,49, 0,0,0, 49,2,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,2, 2,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,2, 2,0,0,0,49},

    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,49,49,49,49, 49,49,49,49,0, 0,0,0,2,2, 2,2,2, 2,2,0,0,0, 0,49,49,49,49, 49,49,49,49,49},

    {49,0,0,0,0, 0,0,49,0,0, 0,0,0,49,0, 0,0,0, 0,49,0,0,0, 0,0,49,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,49,0,0, 0,0,49,0,0, 0,0,0, 0,0,49,0,0, 0,0,49,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,49,0,0, 0,0,0,49,0, 0,0,0, 0,49,0,0,0, 0,0,49,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,49,0,0,0, 0,0,0,0,49, 0,0,0, 49,0,0,0,0, 0,0,0,49,0, 0,0,0,0,49},

    {49,0,0,0,0, 49,0,0,0,0, 0,0,0,0,0, 49,0,49, 0,0,0,0,0, 0,0,0,0,49, 0,0,0,0,49},
    {49,0,0,0,0, 49,0,0,0,0, 0,0,0,0,0, 0,49,0, 0,0,0,0,0, 0,0,0,0,49, 0,0,0,0,49},
    {49,0,0,0,0, 49,0,0,2,2, 2,0,0,0,0, 0,0,0, 0,0,0,0,2, 2,2,0,0,49, 0,0,0,0,49},
    {49,0,0,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,0,0,0,49},

    {49,0,0,0,49, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 49,0,0,0,49},
    {49,0,0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0,0,49},
    {49,0,0,49,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,49,0,0,49},
    {49,0,49,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,49,0,49},
    
    {49,49,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,49,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,49},
    {49,2,2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2, 2,2,2,2,2, 2,2,2,2,2, 2,2,2,2,49}
};

float WORLD_SHIFT_Y = 0.0416666666667f * LEVEL_HEIGHT;

std::vector<std::vector<unsigned int>> level;

void shiftLevel(std::vector<unsigned int> x) {
    level.pop_back();
    level.push_back(x);
    std::rotate(level.begin(), level.end()-1, level.end());
}

int solids[NUM_SOLIDS] = {2,10,13,14,15,49};

const float PI = 3.14159265358979323846f;
const float unit = 0.0625f;

GLuint fontTexture, arneSprites, spaceSprite;

Mix_Music *menuMusic, *gameMusic;

Mix_Chunk *jumpSound, *selectSound, *goalSound, *offSound;

SDL_Window* displayWindow;

ShaderProgram program;

glm::mat4 projectionMatrix;
glm::mat4 viewMatrix;

SDL_Event event;

bool done = false;

const Uint8 *keys;

float gravity_y = -3.0f;

enum EntityType { PLAYER, ENEMY };

// End Global Data

class SpriteData {
    public:
        SpriteData(){};
        SpriteData(float u, float v, float width, float height):
        u(u), v(v), width(width), height(height){};

        float u, v;
        float width, height;
};

class SheetSprite {
    public:
        SheetSprite(){};
        SheetSprite(GLuint textureID, float u, float v, float width, 
            float height, float size):
            textureID(textureID), u(u),v(v), width(width), height(height),
            size(size){};
        SheetSprite(GLuint textureID, SpriteData data, float size):
            textureID(textureID), u(data.u), v(data.v), width(data.width),
            height(data.height), size(size){};

        float size;
        GLuint textureID;
        float u;
        float v;
        float width;
        float height;

        void Draw(ShaderProgram &program);
};

void SheetSprite::Draw(ShaderProgram &p) {
    glBindTexture(GL_TEXTURE_2D, this->textureID);

    GLfloat texCoords[] = {
        u, v + height,
        u + width, v,
        u, v,
        u + width, v,
        u, v + height,
        u + width, v + height
    };

    float aspect = width / height;
    float vertices[] = {
        -0.5f * size * aspect, -0.5f * size,
        0.5f * size * aspect, 0.5f * size,
        -0.5f * size * aspect, 0.5f * size,
        0.5f * size * aspect, 0.5f * size,
        -0.5f * size * aspect, -0.5f * size,
        0.5f * size * aspect, -0.5f * size,
    };

    glVertexAttribPointer(p.positionAttribute, 2, GL_FLOAT, false, 0, vertices);
    glEnableVertexAttribArray(p.positionAttribute);

    glVertexAttribPointer(p.texCoordAttribute, 2, GL_FLOAT, false, 0, texCoords);
    glEnableVertexAttribArray(p.texCoordAttribute);

    glDrawArrays(GL_TRIANGLES, 0, 6);

    glDisableVertexAttribArray(p.positionAttribute);
    glDisableVertexAttribArray(p.texCoordAttribute);
}

void DrawSpriteSheetSprite(ShaderProgram &p, int index) {
    
    float u = (float)(((int)index) % SPRITE_COUNT_X) / (float) SPRITE_COUNT_X;
    float v = (float)(((int)index) / SPRITE_COUNT_X) / (float) SPRITE_COUNT_Y;

    float spriteWidth = 1.0/(float)SPRITE_COUNT_X;
    float spriteHeight = 1.0/(float)SPRITE_COUNT_Y;

    float texCoords[] = {
        u, v + spriteHeight,
        u + spriteWidth, v,
        u, v,

        u + spriteWidth, v,
        u, v + spriteHeight,
        u + spriteWidth, v + spriteHeight
    };

    float vertices[] = {
        -0.5f, -0.5f,
        0.5f, 0.5f,
        -0.5f, 0.5f,

        0.5f, 0.5f,
        -0.5f, -0.5f,
        0.5f, -0.5f
    };

    glBindTexture(GL_TEXTURE_2D, arneSprites);

    glVertexAttribPointer(p.positionAttribute, 2, GL_FLOAT, false, 0, vertices);
    glEnableVertexAttribArray(p.positionAttribute);

    glVertexAttribPointer(p.texCoordAttribute, 2, GL_FLOAT, false, 0, texCoords);
    glEnableVertexAttribArray(p.texCoordAttribute);

    glDrawArrays(GL_TRIANGLES, 0, 6);

    glDisableVertexAttribArray(p.positionAttribute);
    glDisableVertexAttribArray(p.texCoordAttribute);
}

class Entity {
    public:
        float rotation = 0.0f;

        float width;
        float height;

        glm::vec3 last_position = glm::vec3(0.0f, 0.0f, 0.0f);
        glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f);
        glm::vec3 velocity = glm::vec3(0.0f, 0.0f, 0.0f);
        glm::vec3 acceleration = glm::vec3(0.0f, 0.0f, 0.0f);

        int spriteIndex;

        bool collidedTop = false;
        bool collidedBottom = false;
        bool collidedLeft = false;
        bool collidedRight = false;

        bool collidedSpike = false;
        bool collidedGoal = false;

        EntityType entity_type;

        void Accelerate(float elapsed);
        void MoveX(float elapsed);
        void MoveY(float elapsed);
        void Draw() {
            glm::mat4 modelMatrix = glm::mat4(1.0f);
            modelMatrix = glm::translate(modelMatrix, glm::vec3(position.x, position.y, position.z));
            modelMatrix = glm::scale(modelMatrix, glm::vec3(TILE_SIZE,TILE_SIZE,0.0f));
            program.SetModelMatrix(modelMatrix);
            DrawSpriteSheetSprite(program, spriteIndex);
        }
};

class Player {
    public:

        int headIndex;
        Entity body;
        int legIndex;

        bool airJumped = false;
        bool airDashed = false;
        bool movingLeft = false;

        bool offscreen = false;

        int wins = 0;

        void Draw();
        void Update(float elapsed);
};

void Player::Draw() {

    float angle = 180.0f * (PI / 180.0f);

    // Draw body
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(body.position.x, body.position.y, body.position.z));
    if (movingLeft) {
        modelMatrix = glm::rotate(modelMatrix, angle, glm::vec3(0.0f, 1.0f, 0.0f));
    }
    modelMatrix = glm::scale(modelMatrix, glm::vec3(TILE_SIZE,TILE_SIZE,0.0f));
    program.SetModelMatrix(modelMatrix);
    DrawSpriteSheetSprite(program, body.spriteIndex);

    // Draw head
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(body.position.x, body.position.y+TILE_SIZE, body.position.z));
    if (movingLeft) {
        modelMatrix = glm::rotate(modelMatrix, angle, glm::vec3(0.0f, 1.0f, 0.0f));
    }
    modelMatrix = glm::scale(modelMatrix, glm::vec3(TILE_SIZE,TILE_SIZE,0.0f));
    program.SetModelMatrix(modelMatrix);
    DrawSpriteSheetSprite(program, headIndex);

    // Draw legs
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(body.position.x, body.position.y-(0.5f * TILE_SIZE), body.position.z));
    if (movingLeft) {
        modelMatrix = glm::rotate(modelMatrix, angle, glm::vec3(0.0f, 1.0f, 0.0f));
    }
    modelMatrix = glm::scale(modelMatrix, glm::vec3(TILE_SIZE,TILE_SIZE,0.0f));
    program.SetModelMatrix(modelMatrix);
    DrawSpriteSheetSprite(program, legIndex);
}

void Player::Update(float elapsed) {
    this->body.collidedBottom = false;
    this->body.collidedTop = false;
    this->body.collidedLeft = false;
    this->body.collidedRight = false;
    this->body.collidedGoal = false;
    this->body.collidedSpike = false;
    this->offscreen = false;

    this->body.Accelerate(elapsed);
    this->body.last_position = body.position;
    this->body.MoveY(elapsed);
    this->body.MoveX(elapsed);
}

GLuint LoadTexture(const char *filePath) {
    int w,h,comp;
    unsigned char* image = stbi_load(filePath, &w, &h, &comp, STBI_rgb_alpha);

    if(image == NULL) {
        std::cout << "Unable to load image @ path: " << filePath << ". Make sure the path is correct\n";
        assert(false);
    }

    GLuint retTexture;
    glGenTextures(1, &retTexture);
    glBindTexture(GL_TEXTURE_2D, retTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    
    stbi_image_free(image);
    return retTexture;
}

class TextEntity {
    public:
        std::string entity_text;
        GLuint fontTexture;
        float size;
        float spacing;
        float x, y;

        void DrawText(ShaderProgram &p);
};

void TextEntity::DrawText(ShaderProgram &p) {
    float char_size = 1.0/16.0f;

    std::vector<float> vertexData;
    std::vector<float> textCoordData;

    for(int i=0; i < entity_text.size(); i++) {
        int spriteIndex = (int)entity_text[i];

        float texture_x = (float)(spriteIndex % 16) / 16.0f;
        float texture_y = (float)(spriteIndex / 16) / 16.0f;
        
        vertexData.insert(vertexData.end(), {
            ((size+spacing) * i) + (-0.5f * size), 0.5f * size,
            ((size+spacing) * i) + (-0.5f * size), -0.5f * size,
            ((size+spacing) * i) + (0.5f * size), 0.5f * size,
            ((size+spacing) * i) + (0.5f * size), -0.5f * size,
            ((size+spacing) * i) + (0.5f * size), 0.5f * size,
            ((size+spacing) * i) + (-0.5f * size), -0.5f * size,
        });

        textCoordData.insert(textCoordData.end(), {
            texture_x, texture_y,
            texture_x, texture_y + char_size,
            texture_x + char_size, texture_y,
            texture_x + char_size, texture_y + char_size,
            texture_x + char_size, texture_y,
            texture_x, texture_y + char_size,
        });
    }

    glBindTexture(GL_TEXTURE_2D, fontTexture);

    glVertexAttribPointer(p.positionAttribute, 2, GL_FLOAT, false, 0, vertexData.data());
    glEnableVertexAttribArray(p.positionAttribute);

    glVertexAttribPointer(p.texCoordAttribute, 2, GL_FLOAT, false, 0, textCoordData.data());
    glEnableVertexAttribArray(p.texCoordAttribute);

    glDrawArrays(GL_TRIANGLES, 0, 6 * (int)entity_text.size());

    glDisableVertexAttribArray(p.positionAttribute);
    glDisableVertexAttribArray(p.texCoordAttribute);
}

float lerp(float v0, float v1, float t) {
    return (1.0-t)*v0 + t*v1;
}

float pen(float p0, float p1, float measurement1, float measurement2) {
    float distance = abs(p0 - p1);
    return fabs(distance - (measurement1 * 0.5f) - (measurement2 * 0.5f));
}

void Entity::Accelerate(float elapsed) {
    this->velocity.x = lerp(velocity.x, 0.0f, elapsed * 2.0f);
    if (abs(velocity.x) < 0.016f) {
        this->velocity.x = 0.0f;
    }
    this->velocity.x += acceleration.x * elapsed;

    this->velocity.y = lerp(velocity.y, 0.0f, elapsed * 2.0f);
    if (abs(velocity.y) < 0.016f) {
        this->velocity.y = 0.0f;
    }
    this->velocity.y += acceleration.y * elapsed;
    if (!(collidedBottom)) {
        this->velocity.y += gravity_y * elapsed;
    }
}

void getTileCoords(float worldX, float worldY, int &gridX, int &gridY) {
    gridX = (int)worldX;
    gridY = (int)worldY;
}

void getAdjustedWorldCoords(float x, float y, float &worldX, float &worldY) {
    worldX = (x - (WORLD_SHIFT_X)) / (TILE_SIZE);
    worldY = (y - (WORLD_SHIFT_Y)) / (-TILE_SIZE);
}

// uses gameLevel
bool checkSolid(const int x, const int y, int &block) {
    int blockType;
    switch(gameLevel) {
        case ONE:
            blockType = levelOne[y][x];
            break;
        case TWO:
            blockType = levelTwo[y][x];
            break;
        case THREE:
            blockType = levelThree[y][x];
            break;
    }

    block = blockType;

    for (int i = 0; i < NUM_SOLIDS; i++) {
        if(blockType == solids[i]) {
            return true;
        }
    }

    return false;
}

bool CheckLeftWorldCollide(const Entity right, int &block) {
    int gridX, gridY;
    float worldX, worldY;

    getAdjustedWorldCoords(right.position.x - (0.5f * right.width), right.position.y - (0.5f * right.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(right.position.x - (0.5f * right.width), right.position.y - (0.25f * right.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(right.position.x - (0.5f * right.width), right.position.y, worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(right.position.x - (0.5f * right.width), right.position.y + (0.25f * right.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(right.position.x - (0.5f * right.width), right.position.y + (0.5f * right.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    return false;
}

bool CheckRightWorldCollide(const Entity left, int &block) {
    int gridX, gridY;
    float worldX, worldY;

    getAdjustedWorldCoords(left.position.x + (0.5f * left.width), left.position.y - (0.5f * left.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(left.position.x + (0.5f * left.width), left.position.y - (0.25f * left.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(left.position.x + (0.5f * left.width), left.position.y, worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(left.position.x + (0.5f * left.width), left.position.y + (0.5f * left.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(left.position.x + (0.5f * left.width), left.position.y + (0.25f * left.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    return false;
}

bool CheckTopWorldCollide(const Entity bottom, int &block) {
    int gridX, gridY;
    float worldX, worldY;

    getAdjustedWorldCoords(bottom.position.x + (0.5 * bottom.width), bottom.position.y + (0.25f * bottom.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(bottom.position.x, bottom.position.y + (0.25f * bottom.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(bottom.position.x - (0.5 * bottom.width), bottom.position.y + (0.25f * bottom.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    return false;
}

bool CheckBottomWorldCollide(const Entity top, int &block) {
    int gridX, gridY;
    float worldX, worldY;
    
    getAdjustedWorldCoords(top.position.x + (0.5 * top.width), top.position.y - (0.5f * top.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(top.position.x, top.position.y - (0.5f * top.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    getAdjustedWorldCoords(top.position.x - (0.5 * top.width), top.position.y - (0.5f * top.height), worldX, worldY);
    getTileCoords(worldX, worldY, gridX, gridY);

    if (checkSolid(gridX, gridY, block)) {
        return true;
    }

    return false;
}

void Entity::MoveX(float elapsed) {
    this->position.x += velocity.x * elapsed;

    int block;

    if(CheckLeftWorldCollide(*this, block)) {
        this->position.x = last_position.x;
        this->velocity.x = 0.0f;
        this->collidedLeft = true;

        switch(block) {
            // spike
            case 49:
                this->collidedSpike = true;
                break;
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
                this->collidedGoal = true;
                break;
        }
    } else if (CheckRightWorldCollide(*this, block)) {
        this->position.x = last_position.x;
        this->velocity.x = 0.0f;
        this->collidedRight = true;

        switch(block) {
            // spike
            case 49:
                this->collidedSpike = true;
                break;
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
                this->collidedGoal = true;
                break;
        }
    }
}

void Entity::MoveY(float elapsed) {
    this->position.y += velocity.y * elapsed;

    int block;

    if(CheckBottomWorldCollide(*this, block)) {
        this->position.y = last_position.y;
        this->velocity.y = 0.0f;
        this->collidedBottom = true;

        switch(block) {
            // spike
            case 49:
                this->collidedSpike = true;
                break;
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
                this->collidedGoal = true;
                break;
        }
    } else if (CheckTopWorldCollide(*this, block)) {
        this->position.y = last_position.y;
        this->velocity.y = 0.0f;
        this->collidedTop = true;

        switch(block) {
            // spike
            case 49:
                this->collidedSpike = true;
                break;
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
                this->collidedGoal = true;
                break;
        }
    }
}

void DrawLevel(ShaderProgram &p, unsigned int level[LEVEL_HEIGHT][LEVEL_WIDTH]) {
    std::vector<float> vertexData;
    std::vector<float> texCoordData;

    // unsigned int level[LEVEL_HEIGHT][LEVEL_WIDTH];

    for(int y = 0; y < LEVEL_HEIGHT; y++) {
        for(int x = 0; x < LEVEL_WIDTH; x++) {
            if(level[y][x] != 0) {
                float u = (float)(((int)level[y][x]) % SPRITE_COUNT_X) / (float) SPRITE_COUNT_X;
                float v = (float)(((int)level[y][x]) / SPRITE_COUNT_X) / (float) SPRITE_COUNT_Y;

                float spriteWidth = 1.0f/(float)SPRITE_COUNT_X;
                float spriteHeight = 1.0f/(float)SPRITE_COUNT_Y;

                vertexData.insert(vertexData.end(), {
                    TILE_SIZE * x, -TILE_SIZE * y,
                    TILE_SIZE * x, (-TILE_SIZE * y) - TILE_SIZE,
                    (TILE_SIZE * x) + TILE_SIZE, (-TILE_SIZE * y) - TILE_SIZE,

                    TILE_SIZE * x, -TILE_SIZE * y,
                    (TILE_SIZE * x) + TILE_SIZE, (-TILE_SIZE * y) - TILE_SIZE,
                    (TILE_SIZE * x) + TILE_SIZE, -TILE_SIZE * y
                });

                texCoordData.insert(texCoordData.end(), {
                    u, v,
                    u, v + (spriteHeight),
                    u + spriteWidth, v + (spriteHeight),
                    
                    u, v,
                    u + spriteWidth, v + (spriteHeight),
                    u + spriteWidth, v
                });
            }
        }
    }

    glBindTexture(GL_TEXTURE_2D, arneSprites);

    glVertexAttribPointer(p.positionAttribute, 2, GL_FLOAT, false, 0, vertexData.data());
    glEnableVertexAttribArray(p.positionAttribute);

    glVertexAttribPointer(p.texCoordAttribute, 2, GL_FLOAT, false, 0, texCoordData.data());
    glEnableVertexAttribArray(p.texCoordAttribute);

    glDrawArrays(GL_TRIANGLES, 0, vertexData.size()/2);

    glDisableVertexAttribArray(p.positionAttribute);
    glDisableVertexAttribArray(p.texCoordAttribute);
}

class GameState {
    public:
        Player player1;
        Player player2;
        Entity enemies[5];

        void Setup();
        void Render();
        void Update(float elapsed);
        void ProcessEvents();
};

GameState gameState;

class MenuState {
    public:
        TextEntity titleText;
        TextEntity subText;
        TextEntity byText;
        TextEntity startText;
        TextEntity quitText;

        void Setup();
        void Render();
        void ProcessEvents();
};

MenuState menuState;

class OverState {
    public:
        TextEntity winnerText;
        TextEntity p1WinsText;
        TextEntity p2WinsText;
        TextEntity quitText;

        void Setup();
        void Render();
        void ProcessEvents();
};

OverState overState;

void OverState::Setup() {
    std::string winText;
    if (gameState.player1.wins > gameState.player2.wins) {
        winText = "Blue won the game!";
    } else {
        winText = "Red won the game!";
    }
    // setup winner
    this->winnerText.fontTexture = fontTexture;
    this->winnerText.entity_text = winText;
    this->winnerText.size = TILE_SIZE;
    this->winnerText.spacing = 0.0f;
    this->winnerText.x = -1.2f;
    this->winnerText.y = 0.6f;

    // setup p1 score
    std::string p1_score = "Blue Score: " + std::to_string(gameState.player1.wins);
    this->p1WinsText = winnerText;
    this->p1WinsText.entity_text = p1_score;
    this->p1WinsText.y = 0.4f;

    // setup p2 score
    std::string p2_score = "Red Score: " + std::to_string(gameState.player2.wins);
    this->p2WinsText = winnerText;
    this->p2WinsText.entity_text = p2_score;
    this->p2WinsText.y = 0.2f;

    // setup quit text
    this->quitText = winnerText;
    this->quitText.entity_text = "Press ESCAPE to quit to main menu";
    this->quitText.y = 0.0f;
}

void OverState::Render() {
    viewMatrix = glm::mat4(1.0f); 
    program.SetViewMatrix(viewMatrix);

    // Draw winner
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(winnerText.x, winnerText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    winnerText.DrawText(program);

    // Draw p1 score
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(p1WinsText.x, p1WinsText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    p1WinsText.DrawText(program);

    // Draw p2 score
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(p2WinsText.x, p2WinsText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    p2WinsText.DrawText(program);

    // Draw quit text
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(quitText.x, quitText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    quitText.DrawText(program);
}

void OverState::ProcessEvents() {
    while (SDL_PollEvent(&event)) {
        if(event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) {
            done = true;
        } else if (event.type == SDL_KEYDOWN) {
            if(event.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {
                menuState.Setup();
                gameMode = MAIN_MENU;
                Mix_PlayChannel(-1, selectSound, 0);
            }
        }
    }
}

class ContinueState {
    public:
        TextEntity winnerText;
        TextEntity p1WinsText;
        TextEntity p2WinsText;
        TextEntity continueText;
        TextEntity quitText;

        void Setup(bool winner);
        void Render();
        void ProcessEvents();
};

ContinueState continueState;

// true = player1, false = player2
void ContinueState::Setup(bool winner) {
    std::string winText, levelText;
    if (winner) {
        winText = "Blue won the round!";
    } else {
        winText = "Red won the round!";
    }

    switch(gameLevel) {
        case ONE:
            levelText = "Press SPACE to continue to level 2";
            gameLevel = TWO;
            break;
        case TWO:
            levelText = "Press SPACE to continue to level 3";
            gameLevel = THREE;
            break;
        case THREE:
            levelText = "";
            break;
    }

    // setup winner
    this->winnerText.fontTexture = fontTexture;
    this->winnerText.entity_text = winText;
    this->winnerText.size = TILE_SIZE;
    this->winnerText.spacing = 0.0f;
    this->winnerText.x = -1.2f;
    this->winnerText.y = 0.6f;

    // setup p1 score
    std::string p1_score = "Blue Score: " + std::to_string(gameState.player1.wins);
    this->p1WinsText = winnerText;
    this->p1WinsText.entity_text = p1_score;
    this->p1WinsText.y = 0.4f;

    // setup p2 score
    std::string p2_score = "Red Score: " + std::to_string(gameState.player2.wins);
    this->p2WinsText = winnerText;
    this->p2WinsText.entity_text = p2_score;
    this->p2WinsText.y = 0.2f;

    // setup continue text
    this->continueText = winnerText;
    this->continueText.entity_text = levelText;
    this->continueText.y = 0.0f;

    // setup quit text
    this->quitText = winnerText;
    this->quitText.entity_text = "Press ESCAPE to quit to main menu";
    this->quitText.y = -0.2f;
}

void ContinueState::Render() {
    viewMatrix = glm::mat4(1.0f); 
    program.SetViewMatrix(viewMatrix);

    // Draw winner
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(winnerText.x, winnerText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    winnerText.DrawText(program);

    // Draw p1 score
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(p1WinsText.x, p1WinsText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    p1WinsText.DrawText(program);

    // Draw p2 score
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(p2WinsText.x, p2WinsText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    p2WinsText.DrawText(program);

    // Draw continue text
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(continueText.x, continueText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    continueText.DrawText(program);

    // Draw quit text
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(quitText.x, quitText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    quitText.DrawText(program);
}

void ContinueState::ProcessEvents() {
        while (SDL_PollEvent(&event)) {
        if(event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) {
            done = true;
        } else if (event.type == SDL_KEYDOWN) {
            if(event.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {
                menuState.Setup();
                gameMode = MAIN_MENU;
                Mix_PlayChannel(-1, selectSound, 0);
            } else if (event.key.keysym.scancode == SDL_SCANCODE_SPACE) {
                gameState.Setup();
                gameMode = GAME_LEVEL;
                Mix_PlayChannel(-1, selectSound, 0);
            }
        }
    }
}

float lastHighest;

// uses gameLevel
void GameState::Setup() {
    float heightOffset = TILE_SIZE * 2;

    lastHighest = heightOffset - WORLD_SHIFT_Y;

    if (gameLevel == ONE) {
        // Setup game state entities
        // Player1
        this->player1.body.position.x = 0.0f - (TILE_SIZE * 6);
        this->player1.body.position.y = heightOffset - WORLD_SHIFT_Y + TINY_VALUE;
        this->player1.body.last_position = player1.body.position;
        this->player1.body.width = TILE_SIZE;
        this->player1.body.height = 2.0f * TILE_SIZE;

        this->player1.body.spriteIndex = 98;
        this->player1.headIndex = 82;
        this->player1.legIndex = 66;

        // Player2
        this->player2 = player1;
        this->player2.body.position.x = 0.0f - (TILE_SIZE * 4);
        this->player2.body.last_position = player2.body.position;
        this->player2.body.spriteIndex = 99;
        this->player2.headIndex = 83;
    } else {
        this->player1.body.position.x = 0.0f - (TILE_SIZE * 6);
        this->player1.body.position.y = heightOffset - WORLD_SHIFT_Y + TINY_VALUE;
        this->player1.body.last_position = player1.body.position;

        this->player2.body.position.x = 0.0f - (TILE_SIZE * 4);
        this->player2.body.position.y = heightOffset - WORLD_SHIFT_Y + TINY_VALUE;
        this->player2.body.last_position = player2.body.position;
    }

    Mix_HaltMusic();
    Mix_PlayMusic(gameMusic, -1);
}

float towerX = 0.0f + (TILE_SIZE * 5);

// uses gameLevel
void GameState::Render() {
    // Set scroll on player1 x movement (and z movement even though it doesn't matter)
    viewMatrix = glm::mat4(1.0f);
    
    // if (lastHighest <= player1.body.position.y) {
        lastHighest = player1.body.position.y;
    // } 
    
    // if(lastHighest <= player2.body.position.y) {
    //     lastHighest = player2.body.position.y;
    // }

    viewMatrix = glm::translate(viewMatrix, glm::vec3(towerX, -lastHighest,-player1.body.position.z));
    program.SetViewMatrix(viewMatrix);

    // Draw game state entities
    player1.Draw();
    player2.Draw();

    // Draw the game level
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(WORLD_SHIFT_X, WORLD_SHIFT_Y, 0.0f));
    program.SetModelMatrix(modelMatrix);

    switch(gameLevel) {
        case ONE:
            DrawLevel(program, levelOne);
            break;
        case TWO:
            DrawLevel(program, levelTwo);
            break;
        case THREE:
            DrawLevel(program, levelThree);
            break;
    }
}

bool CheckEntityCollision(const Entity left, const Entity right) {
    // Separate into two functions for x and y
    float left_x = left.position.x + (left.width / 2);
    float left_y = left.position.y - (left.height / 2);

    float right_x = right.position.x + (right.width / 2);
    float right_y = right.position.y - (right.height / 2);

    float p_x = glm::abs(left_x - right_x) - ((left.width + right.width) / 2);
    float p_y = glm::abs(left_y - right_y) - ((left.height + right.height) / 2);

    if ((p_x < 0.0f) && (p_y < 0.0f)) {
        return true;
    }

    return false;
}

float last_bottom = -0.85f;

void GameState::Update(float elapsed) {
    player1.Update(elapsed);
    player2.Update(elapsed);

    float distance = std::abs(player1.body.position.y - player2.body.position.y); // distance > 1.25 = loss

    bool player1win = false;
    bool player2win = false;

    // check if someone is off screen
    // if (distance > 1.25f) {
    //     if (player1.body.position.y > player2.body.position.y) {
    //         player1win = true;
    //     } else {
    //         player2win = true;
    //     }
    //     Mix_PlayChannel(-1, offSound, 0);
    // }

    // check if someone collided with a spike
    if (player1.body.collidedSpike) {
        player2win = true;
        Mix_PlayChannel(-1, offSound, 0);
    } else if (player2.body.collidedSpike) {
        player1win = true;
        Mix_PlayChannel(-1, offSound, 0);
    }

    // check if someone reached the goal
    if (player1.body.collidedGoal) {
        player1win = true;
        Mix_PlayChannel(-1, goalSound, 0);
    } else if (player2.body.collidedGoal) {
        player2win = true;
        Mix_PlayChannel(-1, goalSound, 0);
    }

    if(player1win || player2win) {
        if(player1win) {
            this->player1.wins += 1;
        } else {
            this->player2.wins += 1;
        }
        switch(gameLevel) {
            case ONE:
                continueState.Setup(player1win);
                gameMode = CONTINUE;
                break;
            case TWO:
                continueState.Setup(player1win);
                gameMode = CONTINUE;
                break;
            case THREE:
                overState.Setup();
                gameMode = GAME_OVER;
                break;
        }
    }
}

void ProcessJump(Player &player) {
    if (player.body.collidedBottom) {
        player.airJumped = false;
        player.airDashed = false;
        player.body.velocity.y = 3.0f;
        Mix_PlayChannel(-1, jumpSound, 0);
    } else if (!(player.airJumped) && !(player.body.collidedLeft) && !(player.body.collidedRight)) {
        player.airJumped = true;
        player.body.velocity.y = 2.0f;
        Mix_PlayChannel(-1, jumpSound, 0);
    } else if (player.body.collidedLeft) {
        player.movingLeft = false;
        player.body.velocity.y = 1.5f;
        player.body.velocity.x = 2.0f;
        Mix_PlayChannel(-1, jumpSound, 0);
    } else if (player.body.collidedRight) {
        player.movingLeft = true;
        player.body.velocity.y = 1.5f;
        player.body.velocity.x = -2.0f;
        Mix_PlayChannel(-1, jumpSound, 0);
    }
}

void GameState::ProcessEvents() {
    if(keys[SDL_SCANCODE_KP_4]) {
        this->player1.body.acceleration.x = -5.0f;
        this->player1.movingLeft = true;
    } else if (keys[SDL_SCANCODE_KP_6]) {
        this->player1.body.acceleration.x = 5.0f;
        this->player1.movingLeft = false;
    } else {
        this->player1.body.acceleration.x = 0.0f;
    }

    if(keys[SDL_SCANCODE_KP_8]) {
        this->player1.body.acceleration.y = 1.0f;
    } else if (keys[SDL_SCANCODE_KP_5]) {
        this->player1.body.acceleration.y = -1.0f;
    } else {
        this->player1.body.acceleration.y = 0.0f;
    }

    if(keys[SDL_SCANCODE_A]) {
        this->player2.body.acceleration.x = -5.0f;
        this->player2.movingLeft = true;
    } else if (keys[SDL_SCANCODE_D]) {
        this->player2.body.acceleration.x = 5.0f;
        this->player2.movingLeft = false;
    } else {
        this->player2.body.acceleration.x = 0.0f;
    }

    if(keys[SDL_SCANCODE_W]) {
        this->player2.body.acceleration.y = 1.0f;
    } else if (keys[SDL_SCANCODE_S]) {
        this->player2.body.acceleration.y = -1.0f;
    } else {
        this->player2.body.acceleration.y = 0.0f;
    }

    // Process events for game
    while (SDL_PollEvent(&event)) {
        if (event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) {
            done = true;
        } else if(event.type == SDL_KEYDOWN) {
            if(event.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {
                done = true;
            } else if(event.key.keysym.scancode == SDL_SCANCODE_RCTRL) {
                ProcessJump(this->player1);
            } else if(event.key.keysym.scancode == SDL_SCANCODE_LCTRL) {
                ProcessJump(this->player2);
            } else if(event.key.keysym.scancode == SDL_SCANCODE_RSHIFT) {
                if (!(player1.airDashed)) {
                    this->player1.airDashed = true;
                    if (player1.movingLeft) {
                        this->player1.body.velocity.x = player1.body.velocity.x - 2.0f;
                        this->player1.body.velocity.y = player1.body.velocity.y + 0.2f;
                    } else {
                        this->player1.body.velocity.x = player1.body.velocity.x + 2.0f;
                        this->player1.body.velocity.y = player1.body.velocity.y + 0.2f;
                    }
                }
            } else if(event.key.keysym.scancode == SDL_SCANCODE_LSHIFT) {
                if (!(player2.airDashed)) {
                    this->player2.airDashed = true;
                    if (player2.movingLeft) {
                        this->player2.body.velocity.x = player2.body.velocity.x - 2.0f;
                        this->player1.body.velocity.y = player2.body.velocity.y + 0.2f;
                    } else {
                        this->player2.body.velocity.x = player2.body.velocity.x + 2.0f;
                        this->player1.body.velocity.y = player2.body.velocity.y + 0.2f;
                    }
                }
            }
        }
    }
}

void MenuState::Setup() {
    // Setup title
    this->titleText.fontTexture = fontTexture;
    this->titleText.entity_text = "\"Vertical\"";
    this->titleText.size = TILE_SIZE;
    this->titleText.spacing = 0.0f;
    this->titleText.x = -1.2f;
    this->titleText.y = 0.6f;

    // Setup description
    this->subText = titleText;
    this->subText.entity_text = "a two-player runner";
    this->subText.y = 0.4f;

    // Setup signature
    this->byText = titleText;
    this->byText.entity_text = "by Graeme Ferguson";
    this->byText.y = 0.2f;

    // Setup start instructions
    this->startText = titleText;
    this->startText.entity_text = "Press SPACE to start";
    this->startText.y = 0.0f;

    // Setup quit instructions
    this->quitText = titleText;
    this->quitText.entity_text = "Press ESCAPE to quit";
    this->quitText.y = -0.2f;

    Mix_PlayMusic(menuMusic, -1);
}

void MenuState::Render() {
    viewMatrix = glm::mat4(1.0f); 
    program.SetViewMatrix(viewMatrix);

    // Draw title
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(titleText.x, titleText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    titleText.DrawText(program);

    // Draw description
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(subText.x, subText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    subText.DrawText(program);

    // Draw signature
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(byText.x, byText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    byText.DrawText(program);

    // Draw start instructions
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(startText.x, startText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    startText.DrawText(program);

    // Draw quit instructions
    modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(quitText.x, quitText.y, 1.0f));
    program.SetModelMatrix(modelMatrix);
    quitText.DrawText(program);
}

void MenuState::ProcessEvents() {
    while (SDL_PollEvent(&event)) {
        if(event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) {
            done = true;
        } else if (event.type == SDL_KEYDOWN) {
            if(event.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {
                done = true;
            } else if (event.key.keysym.scancode == SDL_SCANCODE_SPACE) {
                gameLevel = ONE;
                gameState.Setup();
                gameMode = GAME_LEVEL;
                Mix_PlayChannel(-1, selectSound, 0);
            }
        }
    }
}

void Setup() {
    SDL_Init(SDL_INIT_VIDEO);
    displayWindow = SDL_CreateWindow("Vertical", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, SDL_WINDOW_OPENGL);
    SDL_GLContext context = SDL_GL_CreateContext(displayWindow);
    SDL_GL_MakeCurrent(displayWindow, context);
    Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 4096);

    #ifdef _WINDOWS
    glewInit();
    #endif

    glViewport(0,0,1280,720);

    program.Load("vertex_textured.glsl", "fragment_textured.glsl");

    projectionMatrix = glm::mat4(1.0f);
    viewMatrix = glm::mat4(1.0f); 

    projectionMatrix = glm::ortho(-1.777f, 1.777f, -1.0f, 1.0f, -1.0f, 1.0f);

    program.SetProjectionMatrix(projectionMatrix);
    program.SetViewMatrix(viewMatrix);

    glUseProgram(program.programID);

    glClearColor(0.529f, 0.808f, 0.922f, 0.0f);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    keys = SDL_GetKeyboardState(NULL);

    fontTexture = LoadTexture("../assets/pixel_font.png");
    arneSprites = LoadTexture("../assets/arne_spritesv4.png");

    menuMusic = Mix_LoadMUS("../sounds/menu_music.mp3");
    gameMusic = Mix_LoadMUS("../sounds/game_music.mp3");
    Mix_VolumeMusic(128);

    jumpSound = Mix_LoadWAV("../sounds/jump.wav");
    selectSound = Mix_LoadWAV("../sounds/select.wav");
    goalSound = Mix_LoadWAV("../sounds/goal_reached.wav");
    offSound = Mix_LoadWAV("../sounds/off_screen_loss.wav");

    menuState.Setup();
}

void Render() {
    glClear(GL_COLOR_BUFFER_BIT);

    switch(gameMode) {
        case MAIN_MENU:
            menuState.Render();
            break;
        case GAME_LEVEL:
            gameState.Render();
            break;
        case CONTINUE:
            continueState.Render();
            break;
        case GAME_OVER:
            overState.Render();
            break;
    }

    SDL_GL_SwapWindow(displayWindow);
}

void Update(float elapsed) {
    switch(gameMode) {
        case GAME_LEVEL:
            gameState.Update(elapsed);
            break;
    }
}

void ProcessEvents() {
    switch(gameMode) {
        case MAIN_MENU:
            menuState.ProcessEvents();
            break;
        case GAME_LEVEL:
            gameState.ProcessEvents();
            break;
        case CONTINUE:
            continueState.ProcessEvents();
            break;
        case GAME_OVER:
            overState.ProcessEvents();
            break;
    }
}

void CleanUp() {
    Mix_FreeMusic(menuMusic);
    Mix_FreeMusic(gameMusic);
    Mix_FreeChunk(jumpSound);
    Mix_FreeChunk(selectSound);
    Mix_FreeChunk(goalSound);
    Mix_FreeChunk(offSound);
}

float lastTicks = 0.0f;

int main(int argc, char *argv[])
{
    Setup();

    float acc = 0.0f;

    while (!done) {
        ProcessEvents();

        float ticks = (float)SDL_GetTicks()/1500.0f;
        float elapsed = ticks - lastTicks;
        lastTicks = ticks;

        elapsed += acc;
        if(elapsed < FIXED_TIMESTEP) {
            acc = elapsed;
            continue;
        }

        int count = 0;

        while(elapsed >= FIXED_TIMESTEP && (count != MAX_TIMESTEPS)) {
            Update(FIXED_TIMESTEP);
            elapsed -= FIXED_TIMESTEP;
            count++;
        }

        acc = elapsed;

        Render();
    }

    CleanUp();

    SDL_Quit();
    return 0;
}